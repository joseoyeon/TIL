## 매개변수 VOID

<pre><code>void function(LPVOID key)
{
    int a = (*int)key;
    struct b = (*struct)key;
}</code></pre>

이런식으로 매개변수 형식에 구애받지않고 내부에서 형변환해서 쓸 수 있음.
아주 편리함.

<pre><code>key->keylength</code></pre>

다만 이런식으로 하면 key 자체는 void형 포인터라서 멤버변수 접근 불가능함.
무조건 형변환해서 사용


## 매크로

<pre><code>#define PRINT(x) printf("%s", x)</code></pre>

요런식으로 매크로정의 가능, 매개변수도 지정할 수 있음.

매크로는 비주얼 스튜디오에서 마우스 가져다대면 ~로 확장됨. 이라고 뜸. 

내가 코드에 매크로를 삽입하면 번역하는 과정에서 매크로에 맞는 소스코드로 확장시켜주기때문이다.

소스코드가 직접적으로 확장되기 때문에 실행파일의 크기가 커질 수 있으나 함수 호출보다 속도가 빠르다는 장점이 있음. 함수는 매개변수 담고 리턴하고 그러한 과정에서 조금 더 느리다고 함. 대신 한개만 구현해놓으면 여러번 재사용이 가능해서 메모리를 적게 차지한다.

## String 관련 자료형

- LPCSTR
- LPSTR
- LPCTSTR
- LPWSTR
- ETC...

C++ 문자열 자료형이 엄청 다양하다.

간단하게 정리를 해보았다.

LP : Long Pointer의 약어, 16bit 표현

C : Constant 상수를 의미

STR : char, Null로 끝나는 배열

T(str) : t_char, t_char는 유니코드에 호환하기 위해 존재하는 자료형이다. 컴파일러의 옵션에 따라 char 혹은 w_char형으로 캐스팅된다.

W : w_char, Wide char로 2byte짜리 char

이 문자들을 조합해서 이해하면 된다.

----
dll에서 entry point 필요한 이유 : 공간 할당 등 초기화 위해서, 리소스만 포함한다면 필요없음 진입점.

매크로와 인라인 함수 차이점 : 매크로는 사용자의 의도와 달리 진짜 때려박기만 하는데 인라인함수는 때려박기만 하지않고 우리가 실제 함수 사용하는것과 동일하게 처리된다. 아래는 매크로가 때려박기만 하는 예시이다.

    #define mul(a) a * a

    mul(3 + 1)  ==  3 + 1 * 3 + 1   //매크로 : 출력 = 7
    inline으로 구현하면 저런것을 신경쓰지 않아도 된다.

기능이 단순한 함수를 자주 호출하면 오버헤드가 발생하니까 인라인 함수를 사용함

~()라는 연산자가 있는데 전체 비트를 반전시킨다 ~8 하면 -9를 뱉음

    #define ROUND_UP(v, u) (((v)+(u-1))& ~(u-1))

이런식으로 v를 u의 배수에 맞출 수 있따. 단, u가 2의 제곱수에 대해서만 돌아가는 것 같다.