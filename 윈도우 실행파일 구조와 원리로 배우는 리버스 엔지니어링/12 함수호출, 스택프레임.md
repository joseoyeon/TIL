# 함수호출, 스택프레임

9, 10장은 리소스에 대한 내용이라 나중에 공부하기로 하고 넘어갔다.

11장은 어셈블리어에 대한 내용인데 시스템소프트웨어에서 배운 내용이랑 크게 다르지 않아서 넘어갔음.

함수 정의 시 {, }와 같은 중괄호는 컴파일과정에서 함수 시작과 끝에서 필요한 다양한 코드로 번역된다.

비활성 레지스터를 보관하거나 지역변수 할당 등 코드가 삽입된다.

C, C++의 코드 대부분은 함수 호출로 이루어지는데 함수 호출, 복귀 시 스택의 구조가 깨지면 안된다.

그래서 함수 호출 관례를 따라야 한다.

## 32bit 함수 호출 관례

는 리버싱 핵심원리랑 DLL파트 어딘가에서 다뤄서 넘어가는데 thiscall이라는건 처음봐서 알아둬야 겠다.

__thiscall또한 Callee가 스택을 정리하는 방식으로 this 포인터를 ECX 레지스터에 저장한 후 매개변수는 스택에 푸시하는 방식이다.

클래스 멤버 함수에 적용되며 클래스 인스턴스의 멤버 함수를 호출할 때 멤버 함수한테 호출한 클래스의 인스턴스를 전달해줘야 한다.

VC++에서는 이걸 ECX에 담아서 전달하고 나머지 매개변수는 다 스택에 역순으로 집어넣는다고 함.

호출관례는 부모랑 자식이 잘 합의를 봐야 한다. 그래야 스택프레임이 안깨지니까

중복 스택 정리가 일어날 수 있고 정리를 안할 수 있고 그래서 주의가 필요하다.

사실 호출 관례는 __cdecl과 나머지로 정의할 수 있다고 한다.

cdecl만 호출자가 스택을 정리하고 나머지는 호출당한 함수가 정리하기 때문이다.

__cdecl은 printf같은 가변 매개변수를 사용가능하게 해준다.

따라서 가변 매개변수를 사용하면 반드시 __cdecl로 선언해야 한다.

과거 PC성능이 안좋을 때 __cdecl은 RET 8 이러면 끝날 것을 여분의 명령어를 더 사용하게 되어 DLL의 내보내기 함수는 무조건 __stdcall로 쓰기로 하였다고 한다.

책에 비휘발성 레지스터라는게 나오는데 음..

ebx, esi, edi, ebp 레지스터를 호출당한 측에서 스택에 보존해야 한다.

그래서 지역변수 공간 할당 후 해당 레지스터 값이 스택에 올라간다.

![image](https://user-images.githubusercontent.com/41255291/51424028-9c0fa600-1c0b-11e9-9c9a-d850cd56fa12.png)

32비트의 스택 프레임

_출처 : 본 책 2권 108p_

## 64bit 함수 호출 관례

__fastcall의 변형된 형태로 1개만 존재한다.

함수 호출 시 신기한 방법을 사용한다. 5번째 매개변수부터 스택에 넣는데 PUSH가 아닌 미리 정해진 스택 영역에 MOV를 통해 전달한다.

이것은 처음 스택 프레임 구성 시 레지스터 백업할 영역, 자기 자신의 지역변수 영역, 자식 함수에 전달할 스택 매개변수 영역, 홈 스페이스라는 영역이라는 것을 모두 미리 할당해놓기때문에 가능하다.

홈스페이스는 레지스터 4종세트로 전달한 매개변수를 다시 스택에 전달하기 위한 공간이다.~~이건 왜 굳이 다시 집어넣는지 모르겠음~~

따라서 PUSH POP이 아닌 그냥 MOV로 정해진 위치에 넣으면 된다.

이러한 전달의 장점은 PUSH POP 이런거 안써서 RSP가 왔다갔다 하지않고 고정되어있다.

또한 RSP가 RBP의 역할을 대신하여 레지스터가 1개 더 늘어난 효과를 가진다.

스택 프레임도 callee caller 정리할 사람 정하지 않아도 된다. 정리할 프레임이 없기 때문

![image](https://user-images.githubusercontent.com/41255291/51424047-d2e5bc00-1c0b-11e9-8812-83bd41fbcfd4.png)

64비트의 스택 프레임

_출처 : 본 책 2권 133p_