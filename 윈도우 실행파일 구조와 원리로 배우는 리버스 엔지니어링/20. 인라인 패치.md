# 인라인 패치

코드를 직접 수정하기 어려울 때 코드 케이브라는 패치 코드를 삽입한 후 실행해 프로그램을 패치시키는 기법.

![image](https://user-images.githubusercontent.com/41255291/51580259-3f600400-1f07-11e9-966e-668d4486a3f6.png)

![image](https://user-images.githubusercontent.com/41255291/51580279-4e46b680-1f07-11e9-8852-18082e72fa76.png)

이 두 창의 텍스트를 바꿔야 한다.

```
PUSHAD
CALL 004010E9
RETN
```

이게 실행 후 코드의 전부라서 조금 들어가서 삽질을 해본다.

레퍼런스 스트링은 모두 암호화되었는지 깨져서 보이거나 없었다.


![image](https://user-images.githubusercontent.com/41255291/51580460-e93f9080-1f07-11e9-85ab-3e67b082e21e.png)

조금 들어가자 마자

XOR하는 루프문이 보이는데 EBX에 담긴 주소가 코드 영역이고 올리디버그에 EntryPoint라는 글자가 보인다.

아마 이곳이 복호화된 엔트리포인트로 추측되니까 EBX에 담긴 주소에 브레이크 포인트 걸고 넘어가본다. 는 오류가 났지만 의미있는 정보를 얻었다.

![image](https://user-images.githubusercontent.com/41255291/51580551-45a2b000-1f08-11e9-82fe-b8052c7bd243.png)

아까 없던 문자열인데 XOR하면서 새로 생긴 모양이다.

![image](https://user-images.githubusercontent.com/41255291/51590786-7990cc00-1f2e-11e9-9af4-c16f0c1e4dff.png)


여기가 어셈블리어로 번역이 되지 않는 문제로 디버거 버전을 바꾸고 다시 시도할 예정...

구버전써도 안되고 내꺼는 왜 저 코드영역이 복호화되어도 저따구로 나오는지..

위쪽은 복호화하면서 제대로 바뀌던데.. 그래서 그냥 읽고 넘어가기로 했다.

솔찍히 코드 흐름은 알겠는데 패치 방법이 진짜.. 처음해보는 사람들이 할 레벨은 아닌 것 같다.

책에서 사용하는 명령어 수업때 들은 명령어인데 이거 써본적 없어서 처음하는 사람들은 그냥 따라해야할듯.. 어셈블리어 뜻도 모를듯하다.

결론적으로 복호화끝나고 OEP로 점프하는 코드가 있는데 그 코드를 코드 케이브영역으로 점프시키는 명령어로 바꾼다.

케이브 영역에서는 복호화가 끝난 문자열들을 덮어씌우는 작업을 한 뒤 다시OEP로 점프한다.

이론은 쉬운데 실제 코드보니까 굉장히 머리아팠음.

이 실습보고 깨달은건 무작정 따라하지말고 그림이랑 글로 흐름을 써가면서 보아야 이해가 빠른 것 같다.