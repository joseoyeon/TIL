# IAT

IMAGE_IMPORT_DESCRIPTOR의 FirstThunk 필드가 가리키고 있는 테이블.

FirstThunk가 가리키는 값 자체는 IAT의 시작주소가 아니다.

![image](https://user-images.githubusercontent.com/41255291/51098649-37b9a480-180f-11e9-87d9-b3abac907ffe.png)

_이미지 출처 : 본 책 431p_

위 이미지 처럼 IAT에서 각 DLL 영역에 해당하는 시작 주소를 담는다.

이미지에 회색 칠 된 부분은 각 영역을 구분하기 위해 NULL로 채워진 영역이다.

로드 된 이후 IAT 각 엔트리의 값은 실제 변수/함수 주소를 가리키게 된다.

DLL 로딩 과정은 아래와 같다.

#### 1. 로드 할 DLL명 획득

IMAGE_IMPORT_DESCRIPTOR의 Name 필드 이용

#### 2. DLL 로딩

로드할 PE크기보다 큰 공간 할당 후 ImageBase에 로딩, 필요하다면 재배치

#### 3. 가져오기 함수/변수 정보 획득

매핑한 PE의 내보내기 섹션에서 얻은 함수/변수 이름 획득

#### 4. 가상 주소 공간에서 함수/변수 포인터 획득

~~책에 아무리봐도 잘못 나온 것 같음~~

함수/변수명으로 AddressOfNames에서 인덱스 획득, 인덱스를 통해 AddressOfNameOrdinals에서 Base를 뺀 서수 획득 

~~책에서는 AddressOfFunctions로 말하는데 아무리봐도 아님~~

AddressOfFunctions에 Base 뺀 서수 인덱스를 가면 실제 함수 주소가 있따.

#### 5. 함수/변수 포인터 저장

지금까지 열심히 얻은 포인터를 저장해야 한다.

아까 보았던 IAT 테이블 영역을 잠시 읽기/쓰기 모드로 변경한 뒤 기록한다.

기록하고 나면 IAT랑 INT랑 내용이 달라지게 되는데 이를 __'DLL 바인딩'__ 이라고 한다.

바인딩이 완료된 후 다시 읽기 모드로 변경한다.

이렇게 해서 DLL이 로딩된다.

그리고 HINT를 사용하면 바인딩을 조금 더 빠르게 할 수 있다.

가져올 함수 이름에는 각각 HINT가 0부터 순서대로 매핑되어있다. 구조체 형식으로 이름배열이랑 묶여서

DLL의 Ordinal Table에 hint를 인덱스로 넣으면 해당하는 Ordinal을 뱉어준다.

그리고 뱉어준 Ordinal을 함수 포인터 배열의 인덱스로 넣으면 해당하는 함수를 문자열 비교 없이 바로 찾을 수 있다.

```C++
WORD wOrdinal = pOrdnTbl[wHint]
return (FARPROC)(pImgBase + pFuncTbl[wOrdinal])
```

## IAT와 __declspec(dllimport)의 효과

컴파일러는 내부에서 쓰는 함수든 가져올 함수든 모든 함수에 대해

    AAA CALL ZZZ
    CCC 함수 내용
    ZZZ JMP CCC

이와 같이 증분 링크마냥 JMP로 다 널려놓는다. 

밖에서 가져올 함수인지 안에서만 쓰는 함수인지 구분을 못하기 때문이다.

따라서 일단 모든 함수에 대해 저렇게 증분 링크를 만들고 나중에 병합하는 듯 하다.

나중에 만약 가져오기 할 함수라면 JMP CCC에 CCC만 제대로 된 주소로 바꾸어 주면 된다.

아니면 그냥 코드를 때려박고..

만약  __declspec(dllimport)를 지정하지 않는다면 해당 함수에 대한 CALL 명령은 증분 링크와 같이 작동한다.

__declspec(dllimport)를 지정하여 헤더파일을 인클루드 할 경우 컴파일러가 미리 이 함수는 가져올 함수라는 것을 알게 된다.

따라서 증분 링크처럼 점프해대지않고 IAT테이블의 해당 함수 주소를 바로 CALL하게 된다.

미세하지만 속도차이가 있을 것이다. 그래서 주요 dll헤더에 다 import처리가 되어있다고 한다.

### 선 바인딩

말그대로 EXE가 실행 되기 전 PE 파일 상태에 미리 바인딩하는 것이다.

미리 DLL이 들어갈 위치를 정해놓는 가정하에 하는 작업이다. 오버헤드를 피하기 위해 이런식으로 한다.

어.. 옛날에는 썼는데 임의 기준 주소 배치 정책에 의해 Dll이 어디 올라갈지 모른다.

만약에 선 바인딩 했는데 dll이 다른데 올라가버린다면 IAT를 다시 갱신해야 한다.

따라서 크게 의미 없는 작업이 되어 요즈음 윈도우 주요 실행파일의 선 바인딩이 다 사라졌다고 한다.