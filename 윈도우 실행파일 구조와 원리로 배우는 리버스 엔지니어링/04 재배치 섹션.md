# 기준 재배치 섹션
은 PE가 메모리에 로드될 때 지정한 ImageBase에 매핑되지 못할 경우 재배치가 필요한데 이 때 사용하는 섹션이다. 또한 최신 VS는 재배치 옵션이 기본적으로 활성화되어있다.

재배치가 일어나며 어떠한 상수변수의 주소는 파일상의 주소에서 이미지상의 주소로 적절하게 변환이 된다.

    재배치 주소 변화량 = Loaded ImageBase -  Disk ImageBase
    로드된 변수,함수.. 주소 = 파일상 주소 + 재배치 주소 변화량
      ㄴ쨋든 절대주소를 필요로하는 어떤 친구의 주소

이런식으로 변환을 해서 RVA를 동일하게 유지시켜서 재배치 후에도 적절한 주소로 매핑될 수 있게한다.

이렇게 ImageBase가 변했을 경우! 모든 절대주소를 요구하는 곳에 대해서 파일 오프셋에서 적절한 RVA로 변환해주는 보정 작업을 수행한다. 이러한 보정 작업을 기준 재배치 라고한다.

그리고 절대주소를 필요로하는 어떤 친구들이 어디에 있는지 모아놓을 필요가 있다.

이러한 내용을 정리해놓은 섹션이 .reloc섹션이라고 할 수 있다. 

.reloc섹션은 보정 작업이 필요한 위치에 대한 인덱스 역할을 하는 테이블로 구성되어있다.

.reloc 섹션은 보정 작업이 필요한 위치(전역변수 혹은 오퍼랜드 등)의 정확한 위치에 대한 RVA를 테이블의 엔트리로 지정한다.

    AAA0 c9 12 56

이러한 AAA0주소의 가상 명령어 C91256이 존재할 때 12가 절대주소로 쓰여있어 재배치가 필요하다면 테이블 엔트리는 AAA0가아닌 오퍼랜드의 정확한 위치 AAA1을 엔트리로 저장한다.

구체적인 재배치 과정은 다음과 같다.

1. OPTIONAL_HEADER의 ImageBase값과 메모리상 ImageBase의 차이인 델타를 구한다.
2. 테이블을 참조하여 보정이 필요한 곳에 델타를 더해 저장한다.
3. 기준 재배치 섹션에 있는 모든 엔트리에 대하여 1, 2를 수행한다.
4. 재배치가 끝난 후 프로그램은 실행가능하게 된다.

기준 재배치 섹션은 PE로드시에만 필요하고 실행뒤에는 크게 의미 없는 섹션이 된다.

따라서 재배치 섹션의 헤더에는 필요에 따라 폐기가 될 수 있다는 IMAGE_SCN_MEM_DISCARDABLE 플래그가 설정된다.

## IMAGE_BASE_RELOCATION
```C++
typedef struct _IMAGE_BASE_RELOCATION
{
    DWORD VirtualAddress;
    DWORD SizeOfBlock;
    //WORD TypeOffset[1];
}IMAGE_BASE_RELOATION
typedef IMAGE_BASE_RERLOCATION UNALIGEND * PIMAGE_BASE_RELOCATION;
```
위와같이 정의된 구조체이다.

VirtualAddrss는 기준 재배치가 시작되어야할 메모리상 번지에 대한 RVA이다.

TypeOffset에 대해 알아보면 알겠지만 기준 재배치 섹션은 하나의 섹션 안에 4k단위의 블록으로 구성된다.

SizeOfBlock은 IMAGE_BASE_RELOCATION 구조체를 포함한 1개 블록의 크기를 의미한다.

TypeOffset은 총 16비트인데 상위 4비트는 재배치 타입을 의미하고 하위 12비트는 VirtualAddress를 기준으로한 재배치 오프셋을 의미한다.

재배치 타입은 여러개가 있는데 3개만 알면 된다고 한다.

```C++
#define IMAGE_REL_BASED_ABSOULUTE 0 //가끔 등장, 4byte단위 맞추기 위한 패딩 TypeOffset에 설정(?)
#define IMAGE_REL_BASED_HIGHLOW 3   //32비트 PE 재배치 타입의 모든 값
#define IMAGE_REL_BASED_DIR64 10    //64비트 PE 재배치 타입의 모든 값
```

여기서 재배치 오프셋이 12바이트라서 2의 12승해서 4k크기의 블록을 가지는 것이다.

최종적으로 이 구조체를 이용해 주소를 보정해주는 과정은 다음과 같다.

1. OPTIONAL_HEADER의 ImageBase값과 메모리상 ImageBase의 차이인 델타를 구한다.
2. IMAGE_BASE_RELOCATION의 VirtualAddress + TypeOffset 하위 12bits를 구하여 RVA를 구함
3. 2에서 구한 값이 최종적으로 보정이 필요한 위치의 RVA값이다.
4. 2와 PE가 로드되었을 때 ImageBase를 더하여 보정이 필요한 위치를 지정
5. 위치에 1에서 구한 델타값을 더해서 덮어씌워 갱신

32비트 PE의 경우 .text영역에 재배치 대상이 90%이상 몰려있는 모습을 보인다.

하지만 64비트의 경우 .text영역에 재배치 대상이 한개도 없다.

그 이유는 RIP 상대적 번지 지정이라는 IA-32에서 지원하지 않는 AMD64의 특수한 기능때문이다.

RIP은 32비트이 EIP 레지스터인데 상대적 번지 지정이란 JMP ~ CALL ~이러한 명령에서 오퍼랜드는 절대주소가 아닌 상대주소로 현재 EIP + 주소를 통해 메모리에 접근한다.

32비트는 이러한 상대적 번지 지정이 JMP, CALL 같은 메모리를 참조하지 않는 특정한 명령어에서만 작동한다.

하지만 64비트에서는 MOV, LEA 등 메모리를 참조하는 명령어 역시 상대적 주소 지정이 가능하다.

따라서 굳이 오퍼랜드를 절대주소로 지정해줄 필요가 없게 되었으므로 코드섹션에서 재배치 또한 일어날 필요가 없어졌다.

## 문제점

1. 재배치할 내용이 많으면 프로그램 로드시 부하가 걸린다.
2. 코드 섹션은 실행가능 속성을 가져서 내용 수정 시 Copy-On-Write라는 매커니즘을 통해 시스템 파일로 원본내용을 백업을 하는 부가적인 작업이 수반된다.

요즘 PC가 빨라서 그닥 문제되진않지만 CPU입장에서는 없으면 좋은게 오버헤드일것이다.

그래서 이전에 MS는 Rebase라는 툴을 배포하였다. 이 툴은가상으로 PE를 배치하고 모듈을 로드해  재배치가 일어나는지 시뮬레이션을 하여 재배치가 최대한 일어나지 않도록 PE를 다시쓰는 그러한 툴이었다고 한다.

하지만 요즘에는 기준 재배치가 그닥 필요없는 EXE까지도 기준 재배치를 기본 옵션으로 권장한다.

그 이유는 두가지 측면이 있다.

### 1. ASLR 보안 기능 지원
Address Space Layout Randomization.

주어진 프로세스의 가상 주소 공간 내에 매핑되는 오브젝트들의 주소를 랜덤화 하는 보안 기술.

_여기부터는 책읽고 소설써본것_

우리는 손으로 디버깅하지만 어떠한 악성 exe파일이 내 프로세스에 대한 핸들을 얻어 특정 오브젝트의 취약점을 이용한다고 가정해보자.

내 프로세스상 어디에 dll이 로드되고 어디에 어떤 변수가 있고 어떤 함수가 있고 미리 안다면 그곳을 공격할 수 있을것이다. 
그러면 악성 exe안에 어떤 코드는 특정 주소에 특정 dll이나 함수 등이 매핑되니 그 영역을 공격하라고 하드코딩이 되어있 수 있다.

하지만 주소를 랜덤으로 지정하면 실행마다 바뀔것이고 어디에 로드될지 예측할 수 없다. 따라서 공격을 어느정도 막을 수 있을 것이다.

_소설 끝_

19장에서 자세히 다룬다고 한다.

### 2. RIP 상대적 번지 지원

Win10의 경우 기업용 말고는 32비트가 지원 안된다고 들었던 것 같다.

대부분 64비트로 넘어가는 추세임을 무시할 수 없다고 한다.

AMD64는 RIP 상대적 번지를 지원하므로 32비트에서 재배치가 빈번하게 일어날 가능성이 높은 코드 영역에 대한 재배치 필요성이 없어졌다.

따라서 애초에 재배치 할 양이 거의 없다.


여기까지가 4장 307페이지에 해당하는 내용이었다.

실습 코드에 대해서는 시간적 한계로 자세히 다루지 못하였고 이론중에서도 이해할 수 있을 정도로만 정리하였다.